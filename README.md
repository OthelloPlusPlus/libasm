# libasm
A static library `libasm.a` containing several basic [assembly functions](inc/libasm.h#L18) designed for an [x86_64](https://en.wikipedia.org/wiki/X86-64) bit architecture.

# Table of Contents
- [Compiling and Execution](#compiling-and-execution)
- [Functions](#functions)
- [Assembly](#assembly)
  - [Basic Structure](#basic-structure)
    - [Sections](#sections)
    - [Instructions](#instructions)
    - [Storage Classes](#storage_classes)
    - [Labels](#labels)
  - [Calling Convention](#calling-convention)
- [Sources](#sources)
- [Creator](#creator)

# Compiling and Execution
The static library `libasm.a` is first compiled using **nasm**, and then archived using **ar**. The prototypes are found in the [libasm.h](inc/libasm.h#L18) header file.
The following commands can be used at the root of the directory.
| Makefile Command | Execution |
| :--------------- | :-------- |
| `make` | Generate **libasm.a** |
| `make display` | Displays the functions contained in **libasm.a** |
| `make demo` | Generates an executable that displays calling convention.<br>The assembly function [DemonstrateCallingConvention](demo/DemonstrateCallingConvention.asm#L18) calls the C function [print_calling_convention](demo/print_calling_convention.c#L17) |
| `make test` | Generates an [executable](test/main.c#L38) that uses and tests the functions contained within **libasm.a** |
| `make run` | Executes the binary generated by demo or test |

Implementing functions from the archive can be done by including the `libasm.h` header file in the relevant C files and adding `-L -lasm` to your [gcc](Makefile#L78) compilation command.

# Functions

| Prototype | Description |
| :-------- | :---------- |
| <code>size_t  <a href="src/ft_strlen.asm#L9">ft_strlen</a>(const char *s);</code> | Calculates the length of the string pointed to by `s` |
| <code>char   *<a href="src/ft_strcpy.asm#L4">ft_strcpy</a>(char *dest, const char *src);</code> | Copies the string pointed to by `src`, including the terminating null byte ('\0'), to the buffer pointed to by `dest`. |
| <code>int     <a href="src/ft_strcmp.asm#L4">ft_strcmp</a>(const char *s1, const char *s2);</code> | Compares the two strings `s1` and `s2`, returning the first difference. |
| <code>ssize_t <a href="src/ft_write.asm#L4">ft_write</a>(int fd, const void *buf, size_t count);</code> | Writes `count` bytes from the buffer `buf` to the file descriptor `fd`. |
| <code>ssize_t <a href="src/ft_read.asm#L4">ft_read</a>(int fd, void *buf, size_t count);</code> | Reads up to `count` bytes from file descriptor `fd` into the buffer `buf`. |
| <code>char   *<a href="src/ft_strdup.asm#L8">ft_strdup</a>(const char *s);</code> | Duplicates string `s` into memory allocated with **malloc**. |
| <code>int     <a href="src/ft_atoi_base.asm#L14">ft_atoi</a>(const char *a);</code> | Converts string `a` to int using the standard base 10. |
| <code>int     <a href="src/ft_atoi_base.asm#L23">ft_atoi_base</a>(const char *a, const char *base);</code> | Converts string `a` to int using the provided base `base`. |
| <code>void    <a href="src/ft_list_push_front.asm#L4">ft_list_push_front</a>(t_list **begin_list, t_list *new);</code> | Adds [tlist](inc/libasm.h#L25) node `new` to the front of the list `begin_list`. |
| <code>int     <a href="src/ft_list_size.asm#L4">ft_list_size</a>(t_list *list);</code> | Calculates the length of the [tlist](inc/libasm.h#L25) list, starting from node `list`. |
| <code>void    <a href="src/ft_list_sort.asm#L5">ft_list_sort</a>(t_list **begin_list, int (*cmp)());</code> | Sorts [tlist](inc/libasm.h#L25) list `list_begin` using function `cmp`'s return value to define the order. |
| <code>void    <a href="src/ft_list_remove_if.asm#L7">ft_list_remove_if</a>(t_list **begin_list, void *data_ref, int (*cmp)());</code> | Removes elements from [tlist](inc/libasm.h#L25) list `begin_list`, using function `cmp` to compare the current node to reference [data](inc/libasm.h#L27) `data_ref` to flag nodes for removal. |
| <code>void    <a href="src/ft_print_registers.asm#L17">ft_print_registers</a>(void);</code> | ⚠️ Not included in the header. Designed to be used within assembly.<br>Displays registers current values. |

# Assembly
Assembly is a low level language close to the machine language. It primairily involes around giving instructions to the processor's registers and accessing memory.

Unlike higher level languages the syntax involves giving direct commands to the processor. The exact architecture of this processor can vary by brand and bit. Thus the exact syntax and assembly compiler varies per system. 

<table>
  <thead>
    <tr>
	  <th>Syntax</th>
	  <th>Compiler</th>
	  <th>File Extention</th>
	</tr>
  </thead>
  <tbody>
    <tr>
      <td>Intel</td>
      <td><a href="https://www.nasm.us/xdoc/2.16.03/html/" target="_blank">NASM</a></td>
      <td>.asm</td>
    </tr>
    <tr>
      <td>AT&T</td>
      <td>GAS</td>
      <td>.s</td>
    </tr>
	<tr><td colspan=3>⚠️ Requires validation</td></tr>
  </tbody>
</table>

Modern compilers, such as gcc, convert higher languages into a compatible assembly syntax before making and linking object files. This project however is only compatible for [x86_64](https://en.wikipedia.org/wiki/X86-64) architecture and is compiled using [nasm](Makefile#L74) and [stored in an archive](Makefile#L67). When executing functions without the use of of a more modern compiler the files must be manually linked together, this is done via [ld](Makefile#L90).

## Basic Structure
The syntax for the assembly language is divided into four aspects.
These aspects of assembly are so interdependant, that explaining one must assume the other aspects are understood.

<details name=segment>
<summary><b>Sections</b> - Different regions of a file, which specify how the syntax should be interpreted and where data is stored.</summary>
<a name="sections"></a>

<table>
  <thead>
    <tr><th colspan=2>Sections</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>.data</td>
      <td>Initializes constants or variables with a set value.</td>
    </tr>
    <tr>
      <td>.bss</td>
      <td>Reserves space for variables with no initialized value.</td>
    </tr>
    <tr>
      <td>.text</td>
      <td>Executable code and function definition</td>
    </tr>
    <tr><td colspan=2>https://docs.oracle.com/cd/E19455-01/806-3773/elf-3/index.html</td></tr>
  </tbody>
</table>

https://www.tutorialspoint.com/assembly_programming/assembly_basic_syntax.htm

https://www.cs.yale.edu/flint/cs421/papers/x86-asm/asm.html

---
</details>

<details name=segment>
<summary><b>Instructions</b> - Instructions for operations to be by the processor.</summary>
<a name="instructions"></a>

Instructions are given to the processor by the use of **mnemonics**. These keywords are translated into **Opcode**, which are numeric instructions which can be send to the processor. The available **mnemonics**, the **Opcode** they relate to, and the expected syntax _varies per architecture_, but are reasonably consistent for a given manufacturer.

The basic syntax for an instruction is a **mnemonic** followed by an **operand** or a label. Some instructions set Status Flag, which specific instructions can respond to. 

```assembly
; Instruction
<mnemonic> <operand>, <operand>

; Example
add	rdi,	rax
```

While there are typicaly _numerous_ **instructions** available, and you can expect the manufacturer to provide documentation for them, only a few handfulls are typically used.

<details><summary>$${\color{orange}\text{Setting register values}}$$</summary>

The ```mov``` instruction is used to set data to a register. While its name pronounced 'move' implies moving data form 1 operand to another, it actually copies and overwrites the information. There are subversions of the instruction such as ```movzx``` and ```movsx```, which are used to maintain data expected output for unsinged and signed numbers respectively.
```assembly
section	.text
CopyValue:
	; Set RAX to 23
	mov	rax,	23
	; Copy value from RAX to RDI
	;	RDI = RAX
	mov	rdi,	rax
	; Copy content from RAX to RDI
	;	RDI = *RAX
	mov	rdi,	[rax]
	; Copy specific content from RAX to RDI
	;	RDI = RAX->data
	mov	RDI,	[rax + 8]
```

The ```xchg``` command can be used to swap the values of 2 registers without the need of a third.
```assembly
section	.text
SwapValues:
	; Swap the values for RDI and RAX
	xchg	rdi,	rax
```

The ```lea``` can be used to retrieve the address of the operand, effectively dereferencing a pointer.
```assembly
section .data
	string	db	"lorem ipsum", 0
section	.text
Dereference:
	; Get the address for the litteral string
	lea	rdi,	[rel string]
```
</details>

<details><summary>$${\color{orange}\text{Manipulating register values}}$$</summary>

Numerous instructions exist to adjust the values of a register. The most commonly used are displayed below, and they are used for simple mathematical operations, such as incrementing, adding and multiplying. 
```assembly
section	.text
IncreaseAndDecrease:
	; Set RCX to 0
	xor	rcx,	rcx
	; ++RCX
	inc	rcx
	; --RCX
	dec	rcx
```

```assembly
section	.text
AddAndSubtract:
	; RSP += 8
	sub	rsp,	8
	; RSP -= 8
	add	rsp,	8
```

```assembly
section	.text
MultiplyAndDivide:
	mov	rdx,	3
	; RDX *= 2
	imul	rdx,	2
	; RDX = RDX * RDI
	imul	rdx,	rdi
	; RDX /= RAX
	idiv	rdx,	rax
```
</details>

<details><summary>$${\color{orange}\text{Stack manipulation}}$$</summary>

There are several approached to allocated memory for the stack. The ```enter``` and ```leave``` instructions can be used at the start of a functions to claim space on the stack, and restoring it before returning. This can also be done manually by manipulating the stack pointers stored on **RSP** and **RBP** using ```push```, ```pop``` and ```mov``` in a specific order. Through either approach **RSP** and **RBP** use eachother to store their original values, allowing the user to manipulate the stack and, asuming the user doesn't corrupt their values, and restore their values at the end.

Using a combination of ```push``` and ```pop``` or ```sub rsp, 8``` and ```add rsp, 8``` a user can then claim space on the stack and use this space as desired. It can be considered counter-intuitive, but ```sub``` is used to increase the stack size, and ```add``` is used to decrease the stack size. When using the ```push``` and ```pop``` instructions the information is copied to the stack, and retrieved using the 'last in, first out' principle.

It is important to note that some functions assume the stack to be alligned to 16 bytes. When calling such functions while unalined causes segfaults. Each ```push``` is equal to ```sub rsp, 8``` and the user should keep in mind that he should always push an even (% 16) amount before calling other functions.
```assembly
section	.text
Function:
	; Store base pointer in stack
	push	rbp
	; Store new stack base in base pointer
	mov		rsp,	rbp
	; Copy RDI and RSI into stack RSP
	push	rdi
	push	rsi
	; Read from stack
	mov	rdi,	[rsp + 8]
	mov	rsi,	[rsp]
	; Reserve space on stack
	sub	rsp,	8
	; Free space from stack
	add	rsp,	8
	; Retrieve and remove data from stack
	pop	rcx	; was RSI
	pop	rdx	; was RDI
	; Restore stack
	mov	rbp,	rsp
	pop	rbp
	; return function
	ret
```
</details>

<details><summary>$${\color{orange}\text{Bitwise operations}}$$</summary>

Comparing bits and storing the results have 3 basic comparisons: `and`, `or`, `xor`. Setting all bits in the destination operand to either true or false depending on the comparison. A simple inversion operation `not` can also be executed swapping true and false. The final 3 comparisons `nand`, `nor`, `nxor` (which might not exist for the architecture) combine the basic operations and the inversion into a single instruction. Creating all meaningful possible comparison results.

| Mnemonic | Syntax | Status Flag | Description | Use case |
| :------- | :----- | :---------: | :---------- | :------- |
| and | `and <dst>, <src>` | ✅ | Sets true of both bits are true | Masking bits |
| or | `or <dst>, <src>` | ✅ | Sets true of either bit is true | Bit flags |
| xor | `xor <dst>, <src>` | ✅ | Sets true of only one bit is true | Toggling bits |
| not | `not <dst>` | ❌ | Sets true if false | Inverting bits |
| shl | `shl <dst>, <imm>` | ✅ | Shift bits left | 2^imm |
| shr | `shr <dst>, <imm>` | ✅ | Shift bits right | 0.5^imm |
| sar | `sar <dst>, <imm>` | ✅ | Shift bits right<br>Preserving signed bit | 0.5^imm |

<table>
	<thead>
		<tr>
			<th rowspan=2>Instruction</th>
			<th colspan=5>1 byte register</th>
		</tr>
		<tr>
			<th><code>&lt;dst&gt;, &lt;src&gt;</code><br><code>11111111, 11111111</code></th>
			<th><code>&lt;dst&gt;, &lt;src&gt;</code><br><code>11111111, 00000000</code></th>
			<th><code>&lt;dst&gt;, &lt;src&gt;</code><br><code>00000000, 11111111</code></th>
			<th><code>&lt;dst&gt;, &lt;src&gt;</code><br><code>00000000, 00000000</code></th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<th><code>and &lt;dst&gt;, &lt;src&gt;</code><br>Sets true if both bits are true</td>
			<td>11111111</td>
			<td>00000000</td>
			<td>00000000</td>
			<td>00000000</td>
		</tr>
		<tr>
			<th><code>or &lt;dst&gt;, &lt;src&gt;</code><br>Sets true if either bit is true</td>
			<td>11111111</td>
			<td>11111111</td>
			<td>11111111</td>
			<td>00000000</td>
		</tr>
		<tr>
			<th><code>xor &lt;dst&gt;, &lt;src&gt;</code><br>Sets true if only one bit is true</td>
			<td>00000000</td>
			<td>11111111</td>
			<td>11111111</td>
			<td>00000000</td>
		</tr>
		<tr>
			<th></th>
			<th><code>&lt;dst&gt;</code><br><code>11111111</code></th>
			<th><code>&lt;dst&gt;</code><br><code>00000000</code></th>
		</tr>
		<tr>
			<th><code>xor &lt;dst&gt;, &lt;dst&gt;</code><br>Sets to 0</td>
			<td>00000000</td>
			<td>00000000</td>
		</tr>
		<tr>
			<th><code>not &lt;dst&gt;</code></br>Sets true if bit is false</td>
			<td>00000000</td>
			<td>11111111</td>
		</tr>
	</tbody>
</table>
</details>

<details><summary>$${\color{orange}\text{Jumping and the Status Flag}}$$</summary>

The conditional jump commands read the [Status Flag](https://en.wikipedia.org/wiki/FLAGS_register) for certain flags. If their conditions are met they they can be used to jump to the indicated **label**. The status flags are set by certain **instructions** and combining them with **conditional jumps** and **labels** allow for structures such as **if statements**, **while loops** and **error handling**.

The ```test``` and ```cmp``` **instructions** are specifically designed to set the **Status Flag** flags, however instructions such as the mathematical ```inc```, ```add```, ```imul``` and bitwise instructions can also set them.
<table>
	<thead>
		<tr>
			<th>Instruction</th>
			<th>Description</th>
			<th>Status Flag</th>
		</tr>
	</thead>
	<tbody>
			<td><code>test &lt;src1&gt;, &lt;src2&gt;</code></td>
			<td>Used to evaluate whether specific bits are set.<br>Executes the <code>and</code> instructions, without overwriting the src.</td>
			<td rowspan=2>PF<br>ZF<br>SF</td>
		</tr>
		<tr>
			<td><code>test &lt;src&gt;, &lt;src&gt;</code></td>
			<td>Used to check for <code>NULL</code><br>Comparing two identical values sets the <a href=https://en.wikipedia.org/wiki/Zero_flag target="_blank">ZF (Zero Flag)</a> if the value is 0.</td>
		</tr>
		<tr>
			<td><code>cmp &lt;src1&gt;, &lt;src2&gt;</code></td>
			<td>Use to compare values.<br>Executes the <code>sub</code> instructions, without overwriting the src.</td>
			<td>CF<br>PF<br>AF<br>ZF<br>SF<br>OF</td>
		</tr>
	<tr>
		<td colspan=3>⚠️ Given the same arguments, the instructions <code>cmp</code> and <code>test</code> set different flags. while <code>test</code> is a more efficient instruction, they are <b><u><i>not interchangeable</i></u></b>.</td>
	</tr>
	</tbody>
</table>

**Conditional jump** instructions can read the **Status Flag** and if the required flags are (un)set, then it redirections the process to the instructed **label**
```assembly
section	.text
Function:
	; if (rdi == NULL) return;
	test	rdi,	rdi
	jz	.Return

; rcx = 0;
	xor	rcx,	rcx

; while (rcx < 10) ++rcx;
.WhileLoop:
	cmp	rcx,	10
	je	.Break
	inc	rcx
	jmp	.WhileLoop
.Break:

.Return:
	ret
```
<table>
	<thead>
		<tr>
			<th>Instructions</th>
			<th>Status Flags</th>
			<th><code>test</code></th>
			<th><code>cmp</code></th>
			<th>Notes</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>jmp</td>
			<td></td>
			<td colspan="3">Unconditional</td>
		</tr>
		<tr><th colspan=5></th></tr>
		<tr>
			<td>je</td>
			<td rowspan="2"><code>ZF=1</code></td>
			<td></td>
			<td><code>if (x == y)</code></td>
			<td></td>
		</tr>
		<tr>
			<td>jz</td>
			<td><code>if (x & y == 0)</code></td>
			<td></td>
			<td></td>
		</tr>
		<tr>
			<td>jne</td>
			<td rowspan="2"><code>ZF=0</code></td>
			<td></td>
			<td><code>if (x != y)</code></td>
			<td></td>
		</tr>
		<tr>
			<td>jnz</td>
			<td><code>if (x & y != 0)</code></td>
			<td></td>
			<td></td>
		</tr>
		<tr><th colspan=5></th></tr>
		<tr>
			<td>jg</td>
			<td><code>ZF=0 && OF=SF</code></td>
			<td>❌</td>
			<td><code>if (x > y)</code></td>
			<td rowspan=4>signed</td>
		</tr>
		<tr>
			<td>jge</td>
			<td><code>OF=SF</code></td>
			<td>❌</td>
			<td><code>if (x >= y)</code></td>
		</tr>
		<tr>
			<td>jl</td>
			<td><code>ZF=0 && OF!=SF</code></td>
			<td>❌</td>
			<td><code>if (x < y)</code></td>
		</tr>
		<tr>
			<td>jle</td>
			<td><code>ZF=1 || OF!=SF</code></td>
			<td>❌</td>
			<td><code>if (x <= y)</code></td>
		</tr>
		<tr>
			<td>ja</td>
			<td><code>ZF=0 && CF=0</code></td>
			<td>❌</td>
			<td><code>if (x > y)</code></td>
			<td rowspan=4>unsigned</td>
		</tr>
		<tr>
			<td>jae</td>
			<td><code>CF=0</code></td>
			<td>❌</td>
			<td><code>if (x >= y)</code></td>
		</tr>
		<tr>
			<td>jb</td>
			<td><code>CF=1</code></td>
			<td>❌</td>
			<td><code>if (x < y)</code></td>
		</tr>
		<tr>
			<td>jbe</td>
			<td><code>ZF=1 || CF=1</code></td>
			<td>❌</td>
			<td><code>if (x <= y)</code></td>
		</tr>
		<tr><th colspan=5></th></tr>
		<tr>
			<td>js</td>
			<td><code>SF=1</code></td>
			<td><code>if (x & y < 0)</code> Most Significant Bit</td>
			<td>⚠️ Use jl instead</td>
			<td>Negative</td>
		</tr>
		<tr>
			<td>jns</td>
			<td><code>SF=0</code></td>
			<td><code>if (x & y >= 0)</code> Most Significant Bit</td>
			<td>⚠️ Use jge instead</td>
			<td>Positive</td>
		</tr>
		<tr>
			<td>jo</td>
			<td><code>OF=1</code></td>
			<td></td>
			<td></td>
			<td>Overflow</td>
		</tr>
		<tr>
			<td>jno</td>
			<td><code>SOF=0</code></td>
			<td></td>
			<td></td>
			<td>No overflow</td>
		</tr>
	</tbody>
</table>

</details>

---
</details>

<details name=segment>
<summary><b>Storage Classes</b> - Storing runtime data</summary>
<a name="storage_classes"></a>

Storage classes are the different locations where a program can store information during execution.

- **Registers** – CPU-internal storage, fastest access.
- **Data Segment** – global/static variables stored in `.data`, `.bss`, or `.rodata`.
- **Stack/Heap Memory** – dynamic or local memory managed at runtime.
</details>


<details name=segment>
<summary><b>Registers</b> - The CPU's working storage.</summary>

### Registers
Registers are sections of the CPU where information can be stored. On a x86_64 system each register can store 64-bits worth of data. They can be used to directly store information, or as an intermediate step required to transfer data between variables.
While in theory all registers can be used to hold any data, there is good practise in place to maintain stability and reliability, preventing unexpected behavior. To this end registers are defined in two type: Caller Saved registers (Scratch) and Callee Saved registers (Preserved), and each register has an intended purpose.

<table border="1" >
	<colgroup>
		<col>
		<col>
		<col>
		<col span="8" style="width: 23px;">
		<col style="width: 480px;">
	</colgroup>
	<thead>
		<tr><th colspan=12 style="text-align: center">Intel X86 Architecture</th></tr>
		<tr>
			<th>Name</th>
			<th>Caller/Callee saved</th>
			<th>Calling convetion</th>
			<th colspan=8>Bytes</th>
			<th>Notes</th>
		</tr>
	</thead>
	<tbody>
		<!-- RAX Accumulator -->
		<tr>
			<td rowspan=4>Accumulator</td>
			<td rowspan=4>🔥 Scratch</td>
			<td rowspan=4>Return value<br>syscall ID</td>
			<td colspan=8>RAX</td>
		</tr>
		<tr>
			<td colspan=4></td>
			<td colspan=4>EAX</td>
		</tr>
		<tr>
			<td colspan=6></td>
			<td colspan=2>AX</td>
		</tr>
		<tr>
			<td colspan=6></td>
			<td colspan=1>AH</td>
			<td colspan=1>AL</td>
		</tr>
		<!-- RBX Base -->
		<tr>
			<td rowspan=4>Base</td>
			<td rowspan=4>🛡️ Preserved</td>
			<td rowspan=4></td>
			<td colspan=8>RBX</td>
		</tr>
		<tr>
			<td colspan=4></td>
			<td colspan=4>EBX</td>
		</tr>
		<tr>
			<td colspan=6></td>
			<td colspan=2>BX</td>
		</tr>
		<tr>
			<td colspan=6></td>
			<td colspan=1>BH</td>
			<td colspan=1>BL</td>
		</tr>
		<!-- RCX Counter -->
		<tr>
			<td rowspan=4>Counter</td>
			<td rowspan=4>🔥 Scratch</td>
			<td rowspan=4>ARG03</td>
			<td colspan=8>RCX</td>
		</tr>
		<tr>
			<td colspan=4></td>
			<td colspan=4>ECX</td>
		</tr>
		<tr>
			<td colspan=6></td>
			<td colspan=2>CX</td>
		</tr>
		<tr>
			<td colspan=6></td>
			<td colspan=1>CH</td>
			<td colspan=1>CL</td>
		</tr>
		<!-- RDX Data -->
		<tr>
			<td rowspan=4>Data</td>
			<td rowspan=4>🔥 Scratch</td>
			<td rowspan=4>ARG02</td>
			<td colspan=8>RDX</td>
		</tr>
		<tr>
			<td colspan=4></td>
			<td colspan=4>EDX</td>
		</tr>
		<tr>
			<td colspan=6></td>
			<td colspan=2>DX</td>
		</tr>
		<tr>
			<td colspan=6></td>
			<td colspan=1>DH</td>
			<td colspan=1>DL</td>
		</tr>
		<!-- RSI Source -->
		<tr>
			<td rowspan=4>Source</td>
			<td rowspan=4>🔥 Scratch</td>
			<td rowspan=4>ARG01</td>
			<td colspan=8>RSI</td>
		</tr>
		<tr>
			<td colspan=4></td>
			<td colspan=4>ESI</td>
		</tr>
		<tr>
			<td colspan=6></td>
			<td colspan=2>SI</td>
		</tr>
		<tr>
			<td colspan=7></td>
			<td colspan=1>SIL</td>
		</tr>
		<!-- RDI Destination -->
		<tr>
			<td rowspan=4>Destination</td>
			<td rowspan=4>🔥 Scratch</td>
			<td rowspan=4>ARG00</td>
			<td colspan=8>RDI</td>
		</tr>
		<tr>
			<td colspan=4></td>
			<td colspan=4>EDI</td>
		</tr>
		<tr>
			<td colspan=6></td>
			<td colspan=2>DI</td>
		</tr>
		<tr>
			<td colspan=7></td>
			<td colspan=1>DIL</td>
		</tr>
		<!-- RSP Stack Pointer -->
		<tr>
			<td rowspan=4>Stack Pointer</td>
			<td rowspan=4>🛡️ Preserved</td>
			<td rowspan=4>ARG06+</td>
			<td colspan=8>RSP</td>
			<td rowspan=4><b>The stack</b><br><br>Should be altered using sub/add, maintaining 16 byte alignment.<br>Can also be altered with push/pop, each alters it by 8 bytes.<br>⚠️ Misalignement can cause segmentation faults.</td>
		</tr>
		<tr>
			<td colspan=4></td>
			<td colspan=4>ESP</td>
		</tr>
		<tr>
			<td colspan=6></td>
			<td colspan=2>SP</td>
		</tr>
		<tr>
			<td colspan=7></td>
			<td colspan=1>SPL</td>
		</tr>
		<!-- RBP Stack Base Pointer -->
		<tr>
			<td rowspan=4>Stack Base Pointer</td>
			<td rowspan=4>🛡️ Preserved</td>
			<td rowspan=4></td>
			<td colspan=8>RBP</td>
			<td rowspan=4>RBP is used to maintain the stack between a function start and end.<br>At the beginning of the funciton its value should be stored on the stack (push) and then the new value of the stack should be stored on RBP (mov).<br><pre>push RBP<br>mov RBP, RSP</pre>When a function completes these steps can be reversed, restoring the stack.<pre>mov RSP, RBP<br>pop RBP</pre>
		</tr>
		<tr>
			<td colspan=4></td>
			<td colspan=4>EBP</td>
		</tr>
		<tr>
			<td colspan=6></td>
			<td colspan=2>BP</td>
		</tr>
		<tr>
			<td colspan=7></td>
			<td colspan=1>BPL</td>
		</tr>
		<!-- R8 -->
		<tr>
			<td rowspan=32>General Purpose</td>
			<td rowspan=4>🔥 Scratch</td>
			<td rowspan=4>ARG04</td>
			<td colspan=8>R8</td>
		</tr>
		<tr>
			<td colspan=4></td>
			<td colspan=4>R8D</td>
		</tr>
		<tr>
			<td colspan=6></td>
			<td colspan=2>R8W</td>
		</tr>
		<tr>
			<td colspan=7></td>
			<td colspan=1>R8B</td>
		</tr>
		<!-- R9 -->
		<tr>
			<!-- <td rowspan=4></td> -->
			<td rowspan=4>🔥 Scratch</td>
			<td rowspan=4>ARG05</td>
			<td colspan=8>R9</td>
		</tr>
		<tr>
			<td colspan=4></td>
			<td colspan=4>R9D</td>
		</tr>
		<tr>
			<td colspan=6></td>
			<td colspan=2>R9W</td>
		</tr>
		<tr>
			<td colspan=7></td>
			<td colspan=1>R9B</td>
		</tr>
		<!-- R10 -->
		<tr>
			<!-- <td rowspan=4></td> -->
			<td rowspan=4>🔥 Scratch</td>
			<td rowspan=4></td>
			<td colspan=8>R10</td>
		</tr>
		<tr>
			<td colspan=4></td>
			<td colspan=4>R10D</td>
		</tr>
		<tr>
			<td colspan=6></td>
			<td colspan=2>R10W</td>
		</tr>
		<tr>
			<td colspan=7></td>
			<td colspan=1>R10B</td>
		</tr>
		<!-- R11 -->
		<tr>
			<!-- <td rowspan=4></td> -->
			<td rowspan=4>🔥 Scratch</td>
			<td rowspan=4></td>
			<td colspan=8>R11</td>
		</tr>
		<tr>
			<td colspan=4></td>
			<td colspan=4>R11D</td>
		</tr>
		<tr>
			<td colspan=6></td>
			<td colspan=2>R11W</td>
		</tr>
		<tr>
			<td colspan=7></td>
			<td colspan=1>R11B</td>
		</tr>
		<!-- R12 -->
		<tr>
			<!-- <td rowspan=4></td> -->
			<td rowspan=4>🛡️ Preserved</td>
			<td rowspan=4></td>
			<td colspan=8>R12</td>
		</tr>
		<tr>
			<td colspan=4></td>
			<td colspan=4>R12D</td>
		</tr>
		<tr>
			<td colspan=6></td>
			<td colspan=2>R12W</td>
		</tr>
		<tr>
			<td colspan=7></td>
			<td colspan=1>R12B</td>
		</tr>
		<!-- R13 -->
		<tr>
			<!-- <td rowspan=4></td> -->
			<td rowspan=4>🛡️ Preserved</td>
			<td rowspan=4></td>
			<td colspan=8>R13</td>
		</tr>
		<tr>
			<td colspan=4></td>
			<td colspan=4>R13D</td>
		</tr>
		<tr>
			<td colspan=6></td>
			<td colspan=2>R13W</td>
		</tr>
		<tr>
			<td colspan=7></td>
			<td colspan=1>R13B</td>
		</tr>
		<!-- R14 -->
		<tr>
			<!-- <td rowspan=4></td> -->
			<td rowspan=4>🛡️ Preserved</td>
			<td rowspan=4></td>
			<td colspan=8>R14</td>
		</tr>
		<tr>
			<td colspan=4></td>
			<td colspan=4>R14D</td>
		</tr>
		<tr>
			<td colspan=6></td>
			<td colspan=2>R14W</td>
		</tr>
		<tr>
			<td colspan=7></td>
			<td colspan=1>R14B</td>
		</tr>
		<!-- R15 -->
		<tr>
			<!-- <td rowspan=4></td> -->
			<td rowspan=4>🛡️ Preserved</td>
			<td rowspan=4></td>
			<td colspan=8>R15</td>
		</tr>
		<tr>
			<td colspan=4></td>
			<td colspan=4>R15D</td>
		</tr>
		<tr>
			<td colspan=6></td>
			<td colspan=2>R15W</td>
		</tr>
		<tr>
			<td colspan=7></td>
			<td colspan=1>R15B</td>
		</tr>
	</tbody>
</table>

Any information stored in a Scratch register is allowed to be altered by any function. While a function could store temporary information in a Scratch register, when calling other functions it may never asume they remain unaltered. Thus, when calling other functions it should store its information in other locations.

When a function alters a Preserved register, it must restore the register before returning to another function. Each function may expect the Preserved register between calls of sub-functions. 
A notable Preserved register is `rsp` (using `rbp` to maintain and store temporary states), which is used to store larger chunks of information. `rsp` is often referred to as 'the stack'.

---
</details>

<!-- </details><details name=segment>
<summary><b>Memory</b> - Storage outside of the CPU. Including the stack.</summary>
<a name="memory"></a>

</details> -->

</details><details name=segment>
<summary><b>Labels</b> - Symbolic names for memory addresses.</summary>
<a name="labels"></a>

Labels in assembly are symbolic names for memory addresses. They are used to define locations in the code base to move around between. Accessing labels can be done in 3 ways:
- **Process Flow** - Labels are passed over by the instruction flow.
- **Jumps** - Continue process at the specified jump. Jump statements can be conditional and can be reconised by their `j**` syntax.
- **Calls** - Using `call` to access a label stores the previous address on the stack. Then using `ret` returns the process to the old address. Effectively turning the label into a **function**.

```assembly
section .text
Label:
	extern	Function
	call	Function
```
```assembly
section .text
; Function asscessible from other files
global	Function
Function:
	push	rbp
	mov		rbp,	rsp
	; do things
	mov		rsp,	rbp
	pop		rbp
	ret
```
```assembly
section .text
;  While loop
	xor	rcx,	rcx
Loop:
	inc	rcx
	cmp	rcx,	10
	jl	Loop
```
```assembly
section .text
; if statement
If:
	cmp	rdi,	rsi
	jne False
True:
	; Do something
	jmp	EndIf
False:
	; Do something else
EndIf:
```
---
</details>

## Calling Convention
When making function calls there is a convention as to which registers are used. While in a custom function this has little effects. When calling library functions however, it defines the order by with arguments are sent. The actual registers vary by processor, and thus the calling convention must be adjusted to the appropriate processor. For the current x86_64 system the calling convention in order of arguments passed is `RDI` => `RSI` => `RDX` => `RCX` => `R8` => `R9` => The Stack. For the return value `RAX` is used.

**Local Function Call**
```assembly
_start:
	; Passing upto 6 arguments to a function by registers
	mov	rdi,	arg00
	mov	rsi,	arg01
	mov	rdx,	arg02
	mov	rcx,	arg03
	mov	r8,		arg04
	mov	r9,		arg05

	; Passing numerous arguments to a function by stack
	; Calling Library functions, such as malloc and printf require stack alignment
	;	The stack then needs to be aligned if it will receive an odd amount of arguments
	;	Otherwise this step can be skipped (and the cleaning up needs to be adjusted accordingly)
	sub	rsp,	8
	push arg08
	push arg07
	push arg06

	; Actual function call
	call function

	; Clean up stack if more than six arguments were passed
	;	Reposition stack by 8 bytes per argument, 
	;	and another 8 if there were an odd number of arguments
	;		3 * 8 + 8 = 32
	add	rsp,	32

	; Setting rax to 60 for exit
	mov	rax,	60
	; Setting exit value to 0
	mov rdi,	0
	; Making a syscall ( => exit(0) )
	syscall

function:
	; Reserve space on the stack to hold the arguments
	;	Depending on the arguments, 8 bytes per argument
	;		Recommended for complex functions and functions that call sub-functions
	;		Can be skipped for simple functions
	;	push rbp; mov rbp,rsp; sub rsp,N
	enter	64,	0

	; Transferring values from Register to locally reserved stack space
	;	Recommended for complex functions and functions that call sub-functions
	;	Can be skipped for simple functions; Then directly use register
	mov [rbp-8],  rdi
	mov [rbp-16], rsi
	mov [rbp-24], rdx
	mov [rbp-32], rcx
	mov [rbp-40], r8
	mov [rbp-48], r9
	; Further arguments are already on the stack and must be retrieved thusly
	;	This requires an intermediate step, using a registry
	;		[rbp+0]: saved RBP (from enter/leave)
	;		[rbp+8]: return address
	mov	rax,		[rbp+16]
	mov	[rbp-56],	rax
	mov	rax,		[rbp+24]
	mov	[rbp-64],	rax
	mov	rax,		[rbp+32]
	mov	[rbp-72],	rax

	; Function Body
	;	This can include any use case

	; Clean up stack
	leave

	; Return to calling function
	ret
```

# Sources
https://www.nasm.us/xdoc/2.16.03/html/nasmdoc0.html

https://syscall.sh/

https://www.cs.uaf.edu/2017/fall/cs301/lecture/09_11_registers.html

https://www.philadelphia.edu.jo/academics/qhamarsheh/uploads/Lecture%2018%20Conditional%20Jumps%20Instructions.pdf

# Creator
Othello<br>
[<img alt="LinkedIn" height="32px" src="https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png" target="_blank" />](https://github.com/OthelloPlusPlus)
[<img alt="LinkedIn" height="32px" src="https://upload.wikimedia.org/wikipedia/commons/thumb/c/ca/LinkedIn_logo_initials.png/600px-LinkedIn_logo_initials.png" target="_blank" />](https://nl.linkedin.com/in/orlando-hengelmolen)

